## 00014 - Smarter, Context-Aware Chatbot (Memory, Specialization, Confirmations)

### Context
Update the web application’s chatbot so it becomes smarter and context-aware for a Daily Expense Tracker. The assistant must remember recent conversation history per chat, specialize in expense tracking only, keep responses short and user-friendly, and support add/modify/delete flows with explicit user confirmation before saving. Backend calls to Gemini must include: system instructions, current chat history, current date, and the latest user message. Do not hallucinate; only use chat history and backend-provided context.

---

### Files To Modify
- `netlify/functions/chat.js`
  - Add a centralized system instruction builder that specializes the assistant as an “Expense Tracker Assistant” and enforces: only answer expense-related questions, keep replies short, self-aware guidance on “how do I use this?”, and no hallucinations.
  - Extend Gemini integration to accept structured inputs: `{ systemInstructions, currentDateIso, chatHistory, latestUserMessage }` and compile them into the request so each API call includes all four.
  - Expand intent detection to cover: `ADD`, `MODIFY`, `DELETE`, `QUERY`, `CONFIRM`, `CLARIFY`.
  - Implement two-step confirmation flows for `ADD`, `MODIFY`, and `DELETE`:
    - Step 1 (propose): Parse the user request (using Gemini where applicable), produce a normalized proposal payload, and reply with a short summary asking the user to confirm.
    - Step 2 (commit): On explicit user confirmation, persist changes via Supabase and respond with a short confirmation.
  - Ensure any Gemini prompts for parsing or planning include the current date and recent chat turns to maintain context (last N messages, e.g., 20, role+content only).
  - Keep the deterministic totals path (`answerSpendQuestion`) for calculations; use Gemini only for intent and extraction/planning.
  - Update the answer generation prompt to stay brief and refuse unrelated questions.

- `src/components/ChatPage.vue`
  - Maintain in-memory chat history (existing `messages` array). Send the last N messages as `history` on each request, alongside the latest user `question`.
  - Add a “New chat” control that clears local `messages` to start fresh (reset welcome message) and consequently sends empty history next time.
  - Handle two-step confirmations: when backend replies with `confirmationRequired` and a normalized `proposal`, render the summary as the assistant message and wait for the user’s explicit confirmation (e.g., user types “yes” or taps a confirm button). On confirm, send a follow-up request carrying the `confirm` payload to commit.

- `src/components/ChatModal.vue`
  - Mirror the `ChatPage.vue` changes: send `history`, support “New chat”, and handle confirmation flows.

- `src/lib/supabase.js`
  - No schema changes required. Reuse existing helpers: `insertExpense`, `updateExpense`, `deleteExpense`.
  - Optionally add a small helper to fetch recent expenses (e.g., `fetchRecentExpenses(userId, limit)`), if needed to resolve ambiguous modify/delete requests during confirmation.

---

### Technical Approach & Algorithms
1) System Instructions (backend)
   - Build a consistent instruction string, e.g.:
     - Identity: “You are the Expense Tracker Assistant for a Daily Expense Tracker web app.”
     - Scope: “Only answer questions related to tracking expenses. If asked unrelated topics, briefly say you only handle expenses.”
     - Behavior: “Be concise. If asked ‘how do I use this?’, explain briefly how to add, modify, delete, and retrieve expenses.”
     - Safety: “Do not invent data. Use only provided chat history, current date, and any backend-provided JSON/context.”
     - Confirmation: “When adding/modifying/deleting, you must ask the user to confirm before saving.”

2) Chat Memory Packaging (backend + frontend)
   - Frontend sends `history` with the last N turns as `{ role: 'user'|'assistant', content: string }`.
   - Backend composes the Gemini request as:
     - `systemInstructions`
     - `currentDateIso` (UTC `YYYY-MM-DD`)
     - `chatHistory` (latest first or chronological; be consistent and documented)
     - `latestUserMessage`
   - For Gemini calls that currently pass a single prompt string, refactor to a helper that concatenates these elements into the final prompt or uses role-based `contents` consistently.

3) Intents & Routing (backend)
   - Extend `detectIntent(...)` to return one of: `ADD | MODIFY | DELETE | QUERY | CONFIRM | CLARIFY` based on `latestUserMessage` plus `chatHistory` and `currentDateIso`.
   - Route:
     - `ADD` → parse proposal, return `{ confirmationRequired: true, proposal }` with a brief natural summary.
     - `MODIFY` → parse target row and changes (cost/quantity/date; note: there is no category field in the current schema). Return `{ confirmationRequired: true, proposal }`.
     - `DELETE` → parse target row. Return `{ confirmationRequired: true, proposal }`.
     - `CONFIRM` → if the prior step produced a `proposal` and the user’s latest message confirms, execute the operation via Supabase and return a short confirmation.
     - `QUERY` → compute deterministically via Supabase (`answerSpendQuestion`) and return a short answer.
     - `CLARIFY` → ask the user to specify add vs query vs modify vs delete.

4) Add / Modify / Delete Proposals (backend)
   - `ADD` proposal:
     - Use Gemini extraction (like current `tryAddFromNaturalText`) but do not persist. Normalize to `{ date, items: [{ item, quantity, cost }] }`. Return a short summary (“Add: bread ×3 (36) for today. Confirm?”).
   - `MODIFY` proposal:
     - Use Gemini to extract target identification and changes. Targets should be resolvable to a single expense row (e.g., “the bread from yesterday”). If ambiguous, respond asking for clarification (include minimal disambiguation options).
     - Normalize to `{ id, update: { item?, cost?, quantity?, date? } }` (note: no `category` column exists; if a user asks to change category, treat it as renaming `item` or ask to clarify).
   - `DELETE` proposal:
     - Similar to modify: resolve a single row and return `{ id }` with a short summary (“Delete bread (D36) on 2025-01-05? Confirm?”).

5) Confirmation Commit (backend)
   - Accept a `confirm` object in the request body, e.g., `{ type: 'ADD'|'MODIFY'|'DELETE', payload }`.
   - Perform the operation using `src/lib/supabase.js` helpers. Return `{ ok: true, answer, added|updated|deleted }` with a short message.
   - Ensure RLS-safe scoping (use `supabase.auth.getUser()` to resolve `user_id`).

6) Calculations and History Retrieval (backend)
   - Keep `answerSpendQuestion` for totals/averages/comparisons using deterministic queries. Expand phrasing to handle quick comparisons (e.g., “this week vs last week”) by running two ranges and returning a concise difference if the user asks for it.
   - Continue supporting relative dates: “today”, “yesterday”, “this week”, “last week”, “this month”. Ensure summaries remain brief.

7) Frontend Integration (ChatPage.vue, ChatModal.vue)
   - Request payload shape: `{ question, history, confirm? }`.
   - History: use the local `messages` array. Truncate to last N (e.g., 20). Strip any transient “Thinking…” placeholder before sending.
   - New Chat: add a button in the header to clear `messages` and re-add the initial assistant greeting. After clearing, subsequent sends include empty history.
   - Confirmation UX: when `confirmationRequired` is received, render the assistant’s brief proposal and wait for explicit user confirmation (e.g., user types “yes” or clicks a confirm action). On confirm, call the same endpoint with `confirm` carrying the server-provided normalized `proposal`.

8) Guardrails & Non‑Hallucination
   - Prompts must instruct Gemini to refuse unrelated questions and to avoid inventing data. If data is insufficient, respond briefly asking for the needed info.
   - Always include `currentDateIso` and `chatHistory` so temporal and referential context is preserved.

---

### API Shape Changes
- Request (POST `/.netlify/functions/chat`):
  - `question: string`
  - `history?: Array<{ role: 'user'|'assistant', content: string }>` (last N turns)
  - `confirm?: { type: 'ADD'|'MODIFY'|'DELETE', payload: object }` (optional; only present when committing a previously proposed change)

- Response (examples):
  - Proposal: `{ answer: string, confirmationRequired: true, proposal: { ... } }`
  - Commit OK: `{ answer: string, added|updated|deleted: object }`
  - Query: `{ answer: string }`

---

### Notes & Constraints
- The chatbot is specialized for a Daily Expense Tracker and must only answer expense-related questions.
- Keep responses short, clear, and user-friendly.
- Confirm before saving for add/modify/delete.
- Do not hallucinate. Only use chat history and backend-provided context (including Supabase results).
- Current schema has no `category`; treat “category” requests as item rename or ask for clarification.

---

### Acceptance
- Memory & Chat Management
  - Chat requests include the last N messages and current date; “New chat” clears history and starts fresh.
  - Gemini calls include system instructions, history, current date, and latest user message.
- Application Awareness
  - Assistant refuses unrelated questions and presents itself as the Expense Tracker Assistant.
- Assistant Behavior
  - On “how do I use this?”, responds briefly with how to add, modify, delete, and retrieve expenses.
  - Responses are concise and user-friendly.
- Core Features
  - Add: Produces a proposal and requires explicit confirmation before insert; on confirm, persists via Supabase.
  - Modify: Proposes an unambiguous update; requires confirmation before update.
  - Delete: Proposes the target row; requires confirmation before delete.
  - Calculations: Answers totals/averages/comparisons succinctly; supports relative dates like “yesterday” and “last week”.
- Constraints
  - No hallucinations; only uses chat history and backend-provided context.
  - Always acts as the “Expense Tracker Assistant,” not a generic chatbot.

