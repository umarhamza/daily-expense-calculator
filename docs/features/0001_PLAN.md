# Feature Plan — Chat persistence and memory for Gemini

## Context
This plan adds persistent chats and history-aware prompts so the assistant can answer with conversation context. It builds on the existing Gemini-backed Netlify function and Supabase integration.

Verbatim user goals:
- I want the chat bot to be smarter
- Add chat to the database
- Users should be able to see create new chats, delete chats, and view chats' history
- In a current chat that should load in chat history memory to Gemini to give Gemini context of the conversation

## Scope
Add Supabase-backed chat storage, CRUD for chats and messages, and load recent chat history into Gemini prompts. Update the UI to manage chats and display history. No product/timeline sections; this is a technical implementation plan only.

## Files to create/update
- netlify/functions/chat.js
  - Accept `chatId` and optional `title` in the POST body.
  - Persist both user messages and assistant responses to Supabase.
  - Load the latest N messages for `chatId` and include them in the Gemini prompt as conversation context.
  - If `chatId` is missing, create a new chat row and return `chatId` in the response.
  - Return shapes: `{ answer, chatId, messageId?, confirmationRequired?, proposal? }`.
- src/lib/supabase.js
  - Add chat data-access helpers (named exports):
    - `createChat(userId, title?)` → inserts chat row, returns `{ data, error }`.
    - `listChats(userId)` → returns chats for user, newest first.
    - `deleteChat(userId, chatId)` → deletes a chat; rely on DB cascade to remove messages.
    - `insertMessage(userId, chatId, role, content, meta?)` → inserts a message row.
    - `listMessages(userId, chatId, limit = 50, beforeId?)` → returns ordered messages for paging.
  - Follow existing patterns: throw only at UI boundary, return `{ data, error }` from lib.
- src/components/ChatPage.vue and/or src/components/ChatModal.vue
  - Add left pane or header menu for chat list: create new chat, select chat, delete chat.
  - When a chat is selected, fetch and render its message history.
  - On send:
    - Ensure a chat exists (create if needed), append the user message, call the Netlify function with `chatId` and minimal local `history` snapshot if needed, then persist the assistant reply received.
  - Handle deletion with confirmation and optimistic UI.
- src/App.vue and navigation components (if necessary)
  - Ensure route/view state supports selecting a chat and passing `chatId` to `ChatPage`/`ChatModal`.

## Database (Supabase)
New tables (names and columns can be adjusted to match conventions):
- chats
  - id: uuid primary key default `uuid_generate_v4()`
  - user_id: uuid not null references `auth.users (id)` (RLS scoped)
  - title: text nullable (first user message snippet or explicit title)
  - created_at: timestamptz default now()
  - updated_at: timestamptz default now()
  - indexes: `(user_id, created_at desc)`
- chat_messages
  - id: uuid primary key default `uuid_generate_v4()`
  - chat_id: uuid not null references `chats (id)` on delete cascade
  - user_id: uuid not null (duplicate for RLS and quick scoping)
  - role: text not null check in ('user','assistant','system')
  - content: text not null
  - token_count: int nullable
  - created_at: timestamptz default now()
  - indexes: `(chat_id, created_at asc)`, `(user_id, created_at desc)`

RLS policies (high level):
- Enable RLS on both tables.
- Policy: users can select/insert/delete only rows where `user_id = auth.uid()`.
- Cascade delete ensures removing a chat removes its messages.

## API and flow changes
Entry: `POST /.netlify/functions/chat`
- Headers: `Authorization: Bearer <access_token>` (already enforced).
- Body (extensions): `{ question: string, chatId?: string, title?: string, history?: Array<{ role: 'user'|'assistant', content: string }>, confirm?: {...} }`.
- Behavior:
  1) Resolve auth user via Supabase client (`supabase.auth.getUser()`).
  2) If `chatId` is absent, create chat (title from `title` or first 60 chars of question) and include `chatId` in response.
  3) Persist incoming user message to `chat_messages`.
  4) Load last N messages (e.g., 20–50) for `chatId` ordered ascending for context.
  5) Build Gemini prompt using conversation transcript + any domain/system instructions; avoid overlong prompts by trimming to token budget.
  6) Call Gemini and capture the assistant text.
  7) Persist assistant message to `chat_messages` with optional token metadata.
  8) Return `{ answer, chatId }` (and existing intent/proposal fields if applicable).

Notes:
- Maintain existing intent router (ADD | MODIFY | DELETE | QUERY | CLARIFY). The context/history should be included in prompts used by those paths, not only the generic Q&A path.
- For confirmation flows, messages may be persisted with metadata; avoid leaking tokens or secrets.

## Prompt construction (history memory)
Algorithm:
1) Fetch the last N messages for `chatId`.
2) Transform to a lightweight transcript string, e.g., `User: ...`, `Assistant: ...` lines.
3) Prepend a compact system primer with the app scope (expenses domain) to keep behavior consistent.
4) Append the latest user `question`.
5) Enforce a max token budget by truncating earliest messages first (oldest-first drop) until under budget.

Where to apply:
- `detectIntentWithContext` and any prompt builders (`getSearchPlanFromGemini`, `buildAdd/Modify/DeleteProposal`, `buildAnswerPrompt`) should accept an optional `history` text block derived from DB messages and include it in the prompt.

## UI behaviors
- Chat list: shows chat titles and relative timestamps; selecting a chat loads its messages.
- New chat: creates a chat immediately or on first send when no `chatId` exists.
- Delete chat: soft confirmation then delete; UI removes it and navigates to a default state.
- History view: virtualized list if needed; show roles, timestamps, and retry action for the last assistant message.
- Error handling: surface brief toasts on failure; do not log secrets.

## Edge cases and constraints
- If auth is missing, return 401 as today.
- If `chatId` does not belong to user or not found, return 404/403.
- Token budget: cap history to avoid Gemini errors; handle truncation gracefully.
- Network or API errors: persist the user message but mark assistant response as failed; UI can show retry.

## Phases
- Phase 1 — Data layer
  - Create `chats` and `chat_messages` tables, indexes, and RLS policies.
  - Add data-access helpers to `src/lib/supabase.js`.
- Phase 2 — API
  - Extend `netlify/functions/chat.js` to accept `chatId`, persist messages, and load history into prompts.
  - Wire history into existing intent and proposal flows.
- Phase 3 — UI
  - Update `ChatPage.vue`/`ChatModal.vue` to manage chat list, selection, deletion, and display history.
  - Ensure send flow uses/creates `chatId` and reflects saved messages.

## Relevant current code references
- `netlify/functions/chat.js` — Gemini orchestration, intent routing, Supabase queries for expenses.
- `src/lib/supabase.js` — Supabase client and existing CRUD helpers pattern.
- `src/components/ChatPage.vue`, `src/components/ChatModal.vue` — Current chat UI and fetch to Netlify function.
- `src/App.vue`, `src/components/BottomNav.vue` — Navigation including Chat view.

