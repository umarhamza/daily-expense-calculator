# Chat Backend Clarification Loop — Rewrite Plan

Brief: Rewrite `netlify/functions/chat.js` so the backend orchestrates a clarify-then-act loop. The backend sends the user message, today’s date, and an explicit tool list to the AI; the AI either requests clarification or decides a tool call. The backend optionally confirms with the user before executing, then runs the tool and returns a final answer.

## Scope and Files
- Update: `netlify/functions/chat.js`
- Reference (no edits required unless integration points change):
  - `src/components/ChatPage.vue` and `src/components/ChatModal.vue` (client expects `answer`, may support `confirmationRequired` and `proposal`)
  - `src/lib/date.js` for date utilities if needed
  - `src/lib/supabase.js` for user/session if needed

## Tool Catalog (initial)
Expose to AI as structured tools (names and JSON schemas):
- add_expense: { item: string, amount: number, date?: ISO string, category?: string }
- get_balance: { range?: string } → number or summary
- list_expenses: { range?: string, category?: string }
- update_expense: { id: number, item?: string, amount?: number, date?: ISO string, category?: string }
- delete_expense: { id: number }

Implementations will initially map to the existing in-memory ExpenseService in `chat.js`:
- add_expense → `service.create(tenantId, roles, item, amount)` (augment to include `date`/`category` later if needed)
- get_balance → sum of `service.list(tenantId)`
- list_expenses → `service.list(tenantId)` with optional filters
- update_expense → `service.update(tenantId, roles, id, patch)`
- delete_expense → `service.delete(tenantId, roles, id)`

## AI Contract
Backend sends a single prompt payload containing:
- message: user’s latest text
- today: ISO date string for “today”
- tools: array of tool descriptors (name, description, json schema)
- history: recent turns (optional, compact)

Model must return STRICT JSON:
- Clarify: { "type": "clarify", "question": string }
- Decide: { "type": "tool_call", "tool": string, "args": object, "confirmationSuggested"?: boolean, "confirmationMessage"?: string }
- Respond only: { "type": "answer", "content": string }

On invalid JSON, retry parse once; on repeated failure, respond with error.

## Flow Specification (maps 1→8 from request)
1) Receive message
- Back end gets the user’s text. Example: “I want to add an item.”
- Input contract for handler: { history: Turn[], message?: string, question?: string, userContext?, confirm? }
- Normalize to `history` + latest user text.

2) Send message to AI
- Back end sends: the user’s message, today’s date (so AI knows the date), and a list of tools (like add_expense, get_balance).
- Build payload: { message, today: new Date().toISOString().slice(0,10), tools, history: compact }
- Call model provider (placeholder OK; keep shim similar to AI-1/AI-2 split). Ensure strict JSON only.

3) AI reads message
- AI checks: Is the message clear? Does it have all the details (amount, category, date)? Or is something missing/unclear?
- If `type=clarify`: backend returns assistant question to client. Do NOT run tools.

4) If message is clear (type=tool_call)
- AI decides: “I can call a tool now.” Example: “Add £200 mechanic fee for today.”
- Validate args by tool schema. If valid and no explicit confirm required, proceed to step 8. If `confirmationSuggested` is true, go to step 7.

5) If message is not clear (type=clarify)
- AI does not call the tool yet. Instead, AI sends a clarifying question back. Example: “What item do you want to add?” or “Did you mean add electricity bill for £200 today?”
- Return to client: { answer: question, confirmationRequired: false }

6) User responds
- If user says “yes”: Back end tells AI: “User confirmed yes.” AI now calls the tool with the details.
- If user says “no” or gives more info: Back end tells AI the new message. AI continues asking until it has all the details.

7) Confirm before action (optional safety)
- Even when all info is ready, AI can still double-check with user: “Would you like me to add electricity bill £200 for today?”
- If user says “yes” → run tool. If user says “no” → AI asks again.
- Backend output for confirm gate: { answer: confirmationMessage || auto-built summary, confirmationRequired: true, proposal: { tool, args } }
- Subsequent confirm request body: { confirm: { tool, args } }

8) Run tool and finish
- When everything is clear and user confirms, backend runs the tool with the final info (including today’s date if needed).
- AI replies: “I’ve added your electricity bill £200 for today.”
- Return success: { answer, added?/updated?/deleted?/listed?/balance? }

Backend loop summary: User → AI → (Clear? Yes → Tool → Done) (No → Ask question → User reply → Confirm → Tool → Done)

## Handler Contract Changes
- Accept and produce only JSON; maintain existing fields for backward compatibility:
  - Accept `question|message` and `history`.
  - Accept `confirm: { tool, args }` to perform execution without re-asking AI.
  - Respond with:
    - Clarify: { answer }
    - Confirm: { answer, confirmationRequired: true, proposal: { tool, args } }
    - Final: { answer, added?|updated?|deleted?|listed?|balance? }

## Algorithms and Logic
- Message normalization: use last user turn from `history` when both provided.
- Strict JSON parse with one retry on failure.
- Tool validation: per-tool schema checks; reject unknown fields.
- Safety: enforce tenant scoping and RBAC via existing service; map domain errors to HTTP codes (reuse `mapDomainErrorToHttp`).
- Confirmation policy: if add/update/delete inferred from vague message, prefer confirmation.
- Balance/list algorithms are simple aggregations over `service.list`.

## Minimal Edits to `chat.js`
- Replace AI-1/AI-2 router with single orchestrator respecting the above contract; keep `ExpenseService` as-is.
- Add tool schema definitions and validators local to `chat.js`.
- Add execution dispatcher for the tool names above.
- Keep existing `jsonRes`, `mapDomainErrorToHttp`, `extractLastUserMessage`, and service code.
- Preserve legacy responses `answer`, `added`, `attemptedAdd` where feasible for UI compatibility.

## Example I/O
- Input: “I want to add an item.” → AI returns clarify → backend returns: “What item do you want to add?”
- Input: “Add electricity bill £200 today” → AI returns tool_call(add_expense, { item: "electricity bill", amount: 200, date: today }) → backend optionally confirms, then executes and replies: “I’ve added your electricity bill £200 for today.”

## Phases
- Phase 1: Implement orchestrator and tool execution in `chat.js` with in-memory service.
- Phase 2: Extend tool args and persistence as needed (date/category fields) and align UI confirmations.