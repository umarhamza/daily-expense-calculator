# Feature Plan — Replace heuristic next‑step logic with Gemini decider

## Context
The current next‑step decision in `netlify/functions/chat.js` relies on a rudimentary `decideNextStep(...)` if/else heuristic. We want the backend to use Gemini AI to decide the next step instead, returning a strict JSON object that the server validates and executes. This keeps our tool catalog, validator, confirmation flow, and service execution unchanged while upgrading the decision quality.

Verbatim requirement:
- In the chat JS file they decide next steps method is not very smart and should use the A I Gemini AI to decide what the next steps is instead of using a rudimentary if else statement.

## Scope
- Replace the local heuristic inside the model shim with a real Gemini decision call that returns STRICT JSON matching our contract: `clarify | tool_call | answer`.
- Keep existing request handling, tool catalog, argument validation, confirmation gate, and execution paths as implemented today.
- Introduce environment‑based configuration for the Gemini API key and model selection without adding heavy SDK dependencies.

Out of scope:
- UI changes beyond existing confirmation and answer handling.
- Database/storage changes.
- New tools or schema redesign.

## Files to update/create
- Update: `netlify/functions/chat.js`
  - Replace `callModelStrict(payload)` implementation to call Gemini rather than the `decideNextStep` heuristic.
  - Preserve `buildModelPayload`, `safeParseAndValidateModelResult`, tool schemas, `validateToolCall`, confirmation flow, and execution dispatcher.
  - Add a minimal provider call helper (inline) with strict JSON response handling and one retry.
- (Optional, future) Create `src/lib/ai/gemini.js` to host provider plumbing if we want to reuse it elsewhere; not required for this change.

## Contract and algorithms
Input to decider (already built by `buildModelPayload`):
- `message`: latest user text.
- `today`: ISO date `YYYY-MM-DD`.
- `tools`: `{ name, schema: { required[], optional[] } }[]` describing available actions.
- `history`: recent turns (compact), if present.

Gemini must return STRICT JSON for exactly one of the following shapes:
- Clarify: `{ "type": "clarify", "question": string }`
- Tool call: `{ "type": "tool_call", "tool": string, "args": object, "confirmationSuggested"?: boolean, "confirmationMessage"?: string }`
- Answer only: `{ "type": "answer", "content": string }`

Server‑side flow (step‑by‑step):
1) Build decider prompt inputs from `buildModelPayload(userText, today, tools, history)`.
2) Call Gemini with instructions to output strict JSON only (no prose), describing the three allowed shapes and including the tool catalog for grounding.
3) Parse response as JSON and pass it through `safeParseAndValidateModelResult`.
4) If invalid, retry once with a stricter system nudge; if still invalid, return 500 `{ error: 'Server error', detail: 'Model output invalid' }` (existing behavior).
5) Route by `decision.type` as today:
   - `clarify` → return `{ answer: question }` (and `attemptedAdd` when present).
   - `answer` → return `{ answer }`.
   - `tool_call` → validate with `validateToolCall`; if `confirmationSuggested`, return confirmation payload; else execute via `executeTool` and return the resulting UI shape.

## Gemini provider details (implementation notes)
- Use an environment variable for the API key, e.g., `process.env.GEMINI_API_KEY` (set via Netlify env). Do not log secrets.
- Prefer a lightweight `fetch` call to Gemini over adding SDK dependencies.
- Model: default to a fast reasoning model appropriate for tool selection (e.g., `gemini-1.5-flash`), configurable via `process.env.GEMINI_MODEL`.
- Request shape: send a compact prompt that includes:
  - A short system directive describing the domain and the strict JSON contract.
  - The user `message`, `today` date, last N `history` turns (compact), and the tool catalog with arg schemas.
  - If supported, set `response_mime_type: application/json` (or equivalent) to bias JSON‑only output.
- Timeout and errors: on network timeouts or 429/5xx, map to server error `500` with a safe detail message; do not expose provider internals.

## Minimal edits to `netlify/functions/chat.js`
- Replace body of `async function callModelStrict(payload)` which currently returns `JSON.stringify(decideNextStep(...))` with a real Gemini call.
- Keep `safeParseAndValidateModelResult` and the downstream routing logic unmodified.
- Ensure single retry path remains intact: invalid JSON → one more Gemini call → if invalid, 500.
- Keep the `decideNextStep` function only as a local fallback behind an explicit feature flag (optional) or remove it if not used.

## Acceptance criteria
- The production path no longer uses the heuristic `decideNextStep` for decisions; it calls Gemini.
- Responses from Gemini that match one of the three shapes are accepted and routed as today.
- Invalid JSON responses are retried once and then produce a 500 with `{ error: 'Server error', detail: 'Model output invalid' }`.
- Tool validation and execution behavior is unchanged; confirmation UX remains intact.
- No secrets are logged; the build runs and the Netlify function deploys.

## Edge cases
- Empty or whitespace `message` → Gemini may return `answer` with a greeting; we continue to accept it.
- Ambiguous add/update/delete intents → Gemini should prefer `clarify` or set `confirmationSuggested: true`.
- Provider failures (timeout/429/5xx) → return 500; do not fall back to heuristic unless explicitly feature‑flagged.

## Phases (small)
- Phase 1 — Provider swap
  - Implement Gemini call inside `callModelStrict` with strict JSON instructions and single retry.
  - Wire API key and model selection via env vars.
- Phase 2 — Hardening (optional)
  - Add feature flag to toggle heuristic fallback during rollout; remove once stable.
  - Consider extracting provider code into `src/lib/ai/gemini.js` if reused.

## Relevant current code references
- `netlify/functions/chat.js`
  - `callModelStrict(payload)` — replace shim with Gemini call (core change).
  - `buildModelPayload(...)` — already produces the decider inputs.
  - `safeParseAndValidateModelResult(raw)` — validates response shapes.
  - `validateToolCall(...)`, `executeTool(...)`, `mapDomainErrorToHttp(...)` — keep unchanged.
  - `decideNextStep(...)` — current heuristic; will be superseded by Gemini.

