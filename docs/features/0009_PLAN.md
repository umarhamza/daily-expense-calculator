### Conversational chat with expense CRUD and confirmations (Server + UI wiring)

Brief context: The chatbot should be conversational like a normal AI chat model and also execute app functions (CRUD expenses) for the logged-in user. When a user asks to add, delete, or edit expenses, the bot must confirm unclear requests before execution and acknowledge actions.

### Scope and touchpoints
- **Serverless entrypoint**: `netlify/functions/chat.js` (implement end-to-end request handling; currently a placeholder)
- **Frontend chat surfaces**: `src/components/ChatPage.vue`, `src/components/ChatModal.vue`
  - Already send: `question`, `history[]`, optional `chatId`, optional `title` for new chats
  - Already handle confirmation via `confirmationRequired` + `proposal` and `confirm` follow-up
  - Already handle `added.items` acknowledgement and `attemptedAdd` guidance
- **Data-access (client-side)**: `src/lib/supabase.js`
  - Expense CRUD: `insertExpense`, `updateExpense`, `deleteExpense`, `fetchExpensesByDate`, `fetchExpensesByMonth`
  - Chat persistence: `createChat`, `listChats`, `insertMessage`, `listMessages`, `deleteChat`
- **Model helpers (optional for general chat)**: `src/lib/geminiAgent.js`, `src/lib/prompts/geminiSystemPrompt.js`, `src/lib/dbWhitelist.js`

### Request / response contract for `/.netlify/functions/chat`
- **Request body**
  - `question: string` – the user’s latest input
  - `history: Array<{ role: 'user'|'assistant', content: string }>` – last ~20 turns
  - `chatId?: string` – if omitted, server should create a chat row (using `title` if provided)
  - `title?: string` – optional; used to set new chat title on first turn
  - `confirm?: { type: 'add'|'delete'|'edit', payload: any }` – present only on confirmation step
- **Auth header**
  - `authorization: Bearer <supabase access token>` – required; RLS must enforce per-user access
- **Response body (server chooses appropriate fields)**
  - `answer: string` – natural language bot reply
  - `chatId?: string` – echo or newly created chat id
  - `confirmationRequired?: boolean` – true when a proposal must be confirmed
  - `proposal?: { type: 'add'|'delete'|'edit', items?: any[], target?: any, update?: any, date?: string }` – normalized intent payload
  - `attemptedAdd?: boolean` – true when add intent detected but parsing incomplete; UI shows guidance
  - `added?: { date: string, items: Array<{ item: string, quantity: number, cost: number }> }` – for successful add acknowledgements

### Server implementation details (`netlify/functions/chat.js`)
- **Supabase client (server-side)**
  - Create a supabase-js client using `process.env.VITE_SUPABASE_URL` and `process.env.VITE_SUPABASE_ANON_KEY`
  - Attach user context with the incoming `Authorization: Bearer <token>` header so RLS runs as the user
  - Never log tokens or keys
- **Chat persistence**
  - If `chatId` missing: insert into `chats` with `user_id`, optional `title`; return `chatId`
  - Persist the user message to `chat_messages` with `role='user'`
  - After computing the bot `answer`, persist an assistant row with `role='assistant'`
- **Intent router**
  - Route in this order:
    1) `confirm` branch: execute proposed action (add/delete/edit) using normalized payload
    2) CRUD detection: attempt to detect add/delete/edit on `question`
    3) Fallback conversational reply: use general LLM (or simple stub) to respond
- **CRUD parsing (rule-based, deterministic; no LLM needed)**
  - Extract entities from `question`:
    - Dates: `YYYY-MM-DD`, natural words ("today", "yesterday"), relative ("on Monday") → normalize to `YYYY-MM-DD` (default to today)
    - Money: amounts like `12`, `12.50`, `12,50`, `NPR 12`, `12 each` → parse decimal amount
    - Quantity: `x2`, `×2`, `2x`, or `2` near item → parse integer ≥ 1
    - Items: free-text tokens between separators (comma, "and") minus date/amount/quantity fragments
  - Support comma-separated lists: e.g., "add bread 3 at 12 each, eggs 2 at 15 each"
  - Editing / deletion targeting: prefer most recent matching records for the user; if multiple matches exist for the same day/item, treat as ambiguous
- **Confirmation policy**
  - If any critical slot is missing/ambiguous, return:
    - `confirmationRequired: true`
    - `proposal` describing normalized intent and what will be executed if confirmed
    - `answer` asking for explicit confirmation (plain language)
  - After `confirm` request arrives:
    - Validate payload again
    - Execute Supabase operations
    - Return `answer` acknowledging change; include `added` for add intents
- **Execution algorithms**
  - Add:
    - Inputs: `items: Array<{ item, quantity, cost }>, date`
    - For each item, call `insert` into `expenses` with RLS auth context; collect successful inserts
    - Respond with `added` + concise `answer`
  - Delete:
    - Inputs: either `{ id }` or criteria `{ item, date? }`
    - If criteria resolves to 0 or >1 rows, require confirmation; else delete that row
    - Respond with count and concise `answer`
  - Edit:
    - Inputs: `{ id }` plus `update: { item?, quantity?, cost?, date? }`
    - If `id` missing, resolve candidate by `{ item, date? }`; if multiple, require confirmation
    - Perform update; respond with concise `answer`
- **Fallback conversational reply**
  - If not CRUD and no confirmation flow, generate a short natural reply (can delegate to `geminiAgent` or a simple stub initially). Keep it friendly and concise.

### Frontend notes (no major UI changes required)
- `src/components/ChatPage.vue` and `src/components/ChatModal.vue` already:
  - Send auth token and `history`
  - Handle `confirmationRequired` + `proposal` and send `confirm` payload
  - Surface `added.items` via `emit('added', …)`
- Ensure `answer` remains user-friendly and acknowledges actions (e.g., “Added 2× bread at 12 on 2025-01-02”).

### Step-by-step parsing outline (add intent)
1. Normalize input to lowercase for heuristics while preserving original for item text
2. Detect intent: keywords like `add`, `record`, `log` near money/quantity → `type='add'`
3. Extract date: explicit `YYYY-MM-DD` else map words (today/yesterday) → ISO
4. Split on commas/" and ": segments → candidate items
5. For each segment:
   - Extract `quantity` via `(x|×)?\s*\d+` patterns or leading numbers
   - Extract `cost` via decimal patterns and phrases like `at 12 (each)`
   - Remainder trimmed → `item`
6. Validate: require `item` and `cost`; set `quantity=1` if missing
7. If any item incomplete → `confirmationRequired=true` with `proposal`
8. On confirmation → insert rows and return `added`

### Step-by-step parsing outline (delete intent)
1. Intent: `delete/remove/undo` keywords
2. Try `id` if present; else derive candidates by `{ item, date? }` (default to today)
3. If 0 or multiple matches → `confirmationRequired` with candidate list
4. On confirmation → delete exact `id`

### Step-by-step parsing outline (edit intent)
1. Intent: `edit/update/change` keywords
2. Resolve target by `id` or `{ item, date? }` with recency rule
3. Extract updates: new `cost`, `quantity`, `item`, or `date`
4. If target ambiguous or no updates extracted → `confirmationRequired`
5. On confirmation → perform update

### Authentication and security
- Require `Authorization: Bearer <token>`; reject if missing
- Use anon key + user bearer for Supabase client so RLS enforces ownership
- Never log secrets or tokens
- Validate and sanitize all parsed values before persistence; reject negative costs or invalid dates

### Minimal DB expectations (already present)
- Tables and RLS policies exist: `expenses`, `chats`, `chat_messages`
- Quantity support exists (`supabase/migrations/20250827160000_expenses_add_quantity.sql`)

### Out of scope (for now)
- Advanced analytics queries via LLM/db whitelist
- Streaming model responses
- Multi-currency inference or exchange rates

### Deliverables
- Implement full server logic in `netlify/functions/chat.js`
- Optional: small utility within `netlify/functions/` to construct a Supabase client with the bearer token
- No breaking changes to UI; confirm flows and acknowledgements should work as-is


